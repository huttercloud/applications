apiVersion: v1
kind: ConfigMap
metadata:
  creationTimestamp: "2022-12-12T07:14:28Z"
  labels:
    app.kubernetes.io/name: {{ .Release.Name }}
  name: {{ .Release.Name }}
data:
  script.sh: |
    #!/bin/sh
    set -e

    pip install --upgrade pip
    pip install paramiko scp

    exec python3 /script/synology-certificate.py  upsert.json: |
    
  synology-certificate.py:  
{{ .Files.Get "synology-certificate.py" | indent 4 }}


  apiVersion: v1
data:
  script.sh: |
    
  synology-certificate.py: "#!/usr/bin/env python3\n\n\"\"\"\n    retrieve the certificate
    stored as a kubernetes secret (mnanaged by cert-manager)\n    retrieve the certificate
    from nas.hutter.cloud\n    compare timestamps and if close to expiry replace the
    certificate on the synology nas\n\"\"\"\n\nimport paramiko\nimport scp\nimport
    socket\nimport ssl\nimport sys\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives.serialization
    import Encoding, PublicFormat\nimport logging\nfrom typing import Dict, Tuple\nimport
    re\nimport io\n\n\ndef get_certificate_from_synology(host: str = 'nas.hutter.cloud',
    port: int = 5001) -> x509.Certificate:\n    \"\"\"\n        retrieve the certificate
    from the synology nas\n        thanks to: https://stackoverflow.com/questions/71139519/python-how-to-get-expired-ssl-cert-date\n
    \   \"\"\"\n    context = ssl.create_default_context()\n    context.check_hostname
    = False\n    context.verify_mode = ssl.CERT_NONE\n\n    with socket.create_connection((host,
    port)) as sock:\n        with context.wrap_socket(sock, server_hostname=host)
    as ssock:\n            data = ssock.getpeercert(True)\n            pem_data =
    ssl.DER_cert_to_PEM_cert(data)\n            return x509.load_pem_x509_certificate(pem_data.encode('UTF-8'))\n\ndef
    get_certificate_from_local_secret(certificate_file: str = '/certificate/tls.crt',
    key_file: str = '/certificate/tls.key') -> Tuple[Dict[str, x509.Certificate[],
    str]:\n    \"\"\"\n        get certificate from filesystem (mounted via k8s volume
    mount)\n    \"\"\"\n\n    with open(certificate_file, 'r') as f:\n        certificate_data
    = f.read()\n    with open(key_file, 'r') as f:\n        key_data = f.read()\n\n\n
    \   s = re.compile(\"(-----BEGIN CERTIFICATE-----[\\w\\W]*?-----END CERTIFICATE-----)\")\n
    \   pem_certificates = s.findall(certificate_data)\n    \n    certificates = dict()\n
    \   certificates['cert'] = x509.load_pem_x509_certificate(pem_certificates[0[].encode('UTF-8'))\n
    \   certificates['intermediate'] = x509.load_pem_x509_certificate(pem_certificates[1[].encode('UTF-8'))\n
    \   certificates['root'] = x509.load_pem_x509_certificate(pem_certificates[2[].encode('UTF-8'))\n\n
    \   return (certificates, key_data)\n\ndef upload_certificate_script_to_synology(certificates:
    Dict[str, x509.Certificate[], private_key: str, host: str = 'nas.hutter.cloud',
    username: str = 'admin', ssh_key_file: str = '/ssh-key/private-key', script_path:
    str = '/tmp/synology-certificate.sh'):\n    \"\"\"\n        render and upload
    a bash script to the synology nas\n    \"\"\"\n\n    cert = certificates['cert'].public_bytes(encoding=Encoding.PEM).decode('UTF-8').strip()\n
    \   intermediate = certificates['intermediate'].public_bytes(encoding=Encoding.PEM).decode('UTF-8').strip()\n
    \   root = certificates['root'].public_bytes(encoding=Encoding.PEM).decode('UTF-8').strip()\n
    \   privkey = private_key.strip()\n\n\n    bash_script = f'''\nset -e\n\n# copy
    certificate and key\necho copy privkey\ncat << EOF > /usr/syno/etc/certificate/system/default/privkey.pem\n{privkey}\nEOF\n\necho
    copy cert\ncat << EOF > /usr/syno/etc/certificate/system/default/cert.pem\n{cert}\nEOF\n\necho
    copy chain\ncat << EOF > /usr/syno/etc/certificate/system/default/chain.pem\n{intermediate}\n{root}\nEOF\n\necho
    copy fullchain\ncat << EOF > /usr/syno/etc/certificate/system/default/fullchain.pem\n{cert}\n{intermediate}\n{root}\nEOF\n\n#
    ensure proper permissions\necho set certificate permissions\nchown root:root /usr/syno/etc/certificate/system/default/*.pem\nchmod
    0400 /usr/syno/etc/certificate/system/default/*.pem\n\n# setup synology drive
    certificate\necho copy certs for synology drive\ncp -a /usr/syno/etc/certificate/system/default/*.pem
    /usr/local/etc/certificate/SynologyDrive/SynologyDrive\n\n# restart services\necho
    restart services\n/usr/syno/sbin/synoservice --restart nginx\n/usr/syno/sbin/synoservice
    --restart nmbd\n/usr/syno/sbin/synoservice --restart avahi\n/usr/syno/sbin/synoservice
    --restart ldap-server\n\n# remove script\nset +e\nrm -- \"${{0}}\"\n    '''\n\n
    \   # prepare file like object containing the rendered bash script\n    bash_script_fo
    = io.BytesIO()\n    bash_script_fo.write(bash_script.encode('UTF-8'))\n    bash_script_fo.seek(0)\n\n
    \   # setup ssh connection\n    ssh_private_key = paramiko.RSAKey.from_private_key_file(ssh_key_file)\n
    \   ssh_client = paramiko.SSHClient()\n    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n
    \   ssh_client.connect(hostname=host, username=username, pkey=ssh_private_key)\n\n
    \   # upload file \n    scp_client = scp.SCPClient(ssh_client.get_transport())\n
    \   scp_client.putfo(bash_script_fo, script_path)\n\n    # close all connections\n
    \   scp_client.close()\n    bash_script_fo.close()\n    ssh_client.close()\n\ndef
    execute_certificate_script_on_synology(host: str = 'nas.hutter.cloud', username:
    str = 'admin', ssh_key_file: str = '/ssh-key/private-key', script_path: str =
    '/tmp/synology-certificate.sh'): \n    \"\"\"\n        execute the given script
    on the system with root rights (passwordless sudo required)\n    \"\"\"\n\n    ssh_private_key
    = paramiko.RSAKey.from_private_key_file(ssh_key_file)\n    ssh_client = paramiko.SSHClient()\n
    \   ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh_client.connect(hostname=host,
    username=username, pkey=ssh_private_key)\n    stdin, stdout, stderr = ssh_client.exec_command(f'sudo
    bash {script_path}')\n\n    stdout_content = stdout.read()\n    stderr_content
    = stderr.read()\n\n    if stdout.channel.recv_exit_status() != 0:\n        raise
    Exception(f'error in ssh command - stdout: {stdout_content.decode(\"UTF-8\")},
    stderr: {stderr_content.decode(\"UTF-8\")}.')\n\n    ssh_client.close()\n\n\nif
    __name__ == '__main__':\n\n    try:\n        current_certificate = get_certificate_from_synology()\n
    \       new_certificates_and_key = get_certificate_from_local_secret()\n\n        if
    current_certificate.not_valid_before == new_certificates_and_key[0[]['cert'].not_valid_before:\n
    \           logging.info('Same certificate, nothin todo!')\n            sys.exit(0)\n\n
    \       upload_certificate_script_to_synology(new_certificates_and_key[0[], new_certificates_and_key[1[])\n
    \       execute_certificate_script_on_synology()\n\n    except Exception as e:\n
    \       logging.error(e)\n        sys.exit(1)"
immutable: false
kind: ConfigMap
metadata:
  creationTimestamp: "2022-12-17T20:57:10Z"
  labels:
    app.kubernetes.io/name: synology-certificate
  name: synology-certificate-scripts
  namespace: default
  resourceVersion: "1139496"
  uid: 3388787b-32d3-4eb2-9e9f-fa0952e4e84a
